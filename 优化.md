# 1. 网络方面
## 01. 减少 HTTP 请求
* 一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并返回响应，浏览器接收响应等过程。

## 02. 使用 HTTP2
1. 解析速度快
    * 服务器解析 HTTP1.1 的请求时，必须不断地读入字节，知道遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每帧都有表示帧长度的字段
2. 多路复用
    * HTTP 1.1 如果要同时发起多个请求，就的建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求
    * 在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建
3. 首部压缩
    * HTTP2 提供了首部压缩功能
    * 两个请求中如果有很多相同的数据，将相同的首部存储起来，仅发送他们之间不同的部分，这样就可以节省不少的流量，加快请求时间
    * HTTP2 在客户端和服务端使用"首部表"来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送
    * eg：
        * 客服端按照顺序发送如下请求首部：
            ```    
                Header1: foo
                Header2: bar
                Header3: bat
            ```
        * 当客户端发送请求时，它会根据首部值创建一张表
            | 索引 | 首部名称 | 值 |
            | ---- | ---- | ---- |
            | 62 | Header1 | foo |
            | 63 | Header2 | bar |
            | 64 | Header3 | bat |
        * 服务器收到请求，照样会创建一张表。当客户端发送下一个请求的时候，如果首部相同，就可以直接发送这样的首部块
            ```
                62 63 64
            ```
        * 服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部
4. 优先级
    * HTTP 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理
5. 流量控制
    * 由于一个 TCP 连接流量带宽（根据客户端服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的溜溜多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制
6. 服务器推送
    * 服务器可以对一个客户端请求发送多个响应。
    * 即除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求
    * 例如：浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源

# 2. 客户端渲染和服务端渲染（SSR）
## 客户端渲染
* 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，在渲染
* 渲染过程：（Vue SSR）
    1. 访问客户端渲染的网站
    2. 服务器返回一个包含了引入资源语句和 HTML 文件
    3. 客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 new Vue() 开始实例化并渲染页面

## 服务器渲染
* 服务器返回 HTML 文件，客户端只需解析 HTML
* 优点：首屏渲染快，SEO
* 缺点：配置麻烦，增加服务器的计算压力
* 渲染过程：(Vue SSR)
    1. 访问服务端渲染的网站
    2. 服务器会查看当前路由组件需要哪些资源文件，然后将这些文件填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面
    3. 当客户端接收到这个 HTML 页面时，就可以马上开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 new Vue() 开始实例化并接管页面

## 区别
* 区别在于第二步：客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件

## 使用服务端渲染（SSR）的好处：内容更快的呈现
* eg：网站需要加载完 a b c d 四个文件才能渲染完毕。并且每个文件大小为 1M
    1. 客户端渲染的网站需要加载 4个文件 和 HTML 文件才能完成首页渲染，总计大小为 4M（忽略 HTML 文件大小）。
    2. 而服务端渲染的网站只需要加载一个渲染完毕的 HTML 文件就能完成首页渲染，总计大小为已经渲染完毕的 HTML 文件

# 3. 静态资源使用 CDN
* 内容分布网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。CDN 在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间
## CDN 原理
* 当用户访问一个网站时，如果没有 CDN，过程是这样的：
    1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求
    2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址
    3. 本地 DNS 将 IP 地址发回给浏览器，浏览器再向网站服务器 IP 地址发出请求并得到资源
* 如果用户访问的网站部署了 CDN，过程是这样的：
    1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求
    2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址
    3. 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS
    4. 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求
    5. SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器
    6. 浏览器再根据 SLB 发回的地址重定向到缓存服务器
    7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地
    
# 4. 内容
## 1. 将 CSS 放在文件头部，JavaScript 文件放在底部
* 所有放在 head 标签里的 CSS 和 JS 文件都会阻塞渲染（CSS 不会阻塞 DOM 解析）。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。所以要将 JS 文件放在底部，等待 HTML 解析完了再加载 JS 文件
* 那为什么 CSS 文件还要放在头部呢？
    * 因为先加载 HTML 再加载 JS，会让用户第一时间看到的页面时没有样式的，为了避免这种情况发生，就要将 CSS 文件放在头部
    * 另外 JS 文件也是可以放在头部的，主要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行

## 2. 使用字体图标 iconfont 代替图片图标
* 字体图标是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size 、color 等等。并且字体图标是矢量图，不会失真。并且生成的文件特别小

# 5. 图片优化
## 1. 图片延迟加载
* 在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载
1. 首先可以将图片这样设置，在页面不可见时图片不会加载
```html
    <img data-src="">
```
2. 等页面可见时，使用 JS 加载图片
```javascript
    const img = document.querySelector('img')
    img.src = img.dataset.src
```

## 2. 响应式图片
* 响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片
* 通过 picture 实现
    ```html
        <picture>
            <source srcset = "w1000.jpg" media = "(min-width:801px)">
            <source srcset = "w800.jpg" media = "(min-width:800px)">
            <img src="w800.jpg" alt="">
        </picture>
    ```
* 通过 @media 实现
    ```css
        @media (min-width: 769px) {
            .bg {
                background-image: url(bg1.jpg)
            }
        }
        @media (max-width: 768px) {
            .bg {
                background-image: url(bg2.jpg)
            }
        }
    ```

## 3. 调整图片大小
* 例如：有一个 1920 * 1080 大小的图片，用缩略图的方式展示给用户，并且当用户鼠标悬停在上面时才展示全图。如果用户从未真正将鼠标悬停在缩略图上，则浪费了下载图片的时间
* 解决（两种方案）：
    1. 用两张图来实行优化，一开始，只加载缩略图，当用户悬停在图片上时，才加载大图。
    2. 对大图进行延迟加载，在所有元素都加载后手动更改大图的 src 进行下载

## 4. 降低图片质量
* 例如：JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是当作背景图的时候。用 PS 切背景图时，将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别
* 压缩方法（两种）：
    1. 使用 webpack 插件 image-webpack-loader
        * 用法：npm i -D image-webpack-loader
        * 配置：
            ```javascript
                {
                    test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
                    use: [
                        {
                            loader: 'url-loader',
                            options: {
                                limit: 10000,
                                name: utils.assetsPath('img/[name].[hash:7].[ext]')
                            }
                        },
                        {
                            loader: 'image-webpack-loader',
                            options: {
                                bypassOnDebug: true
                            }
                        }
                    ]
                }
            ```
    2. 通过在线网站进行压缩


## 5. 尽可能利用 CSS3 效果代替图片
* 有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好。因为代码大小通常是图片大小的几分之一甚至几十分之一

## 6. 使用 WebP 格式的图片
* WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一

# 6. 通过 webpack 按需加载代码，提取第三方库，减少 ES6 转为 ES5 的冗余代码
* 懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块永远不会被加载

# 7. 减少重绘重排
## 浏览器渲染过程
1. 解析 HTML 生成 DOM 树
2. 解析 CSS 生成 CSSOM 规则树
3. 解析 JS，操作 DOM 树和 CSSOM 规则树
4. 将 DOM 树与 CSSOM 规则树合并在一起生成渲染树
5. 遍历渲染树开始布局，计算每个节点的位置大小信息
6. 浏览器将所有图层的数据发送给 GPU，GPU 将图层合成并显示在屏幕上
![1_1](./src/image/优化_images/7.png)

## 重排
* 当改变 DOM 元素位置或者大小时，会导致浏览器重新生成渲染树，这个过程叫重排

## 重绘
* 当重新生成渲染树后，就要将渲染树每个节点绘制到屏幕上，这个过程叫重绘。不是所有的动作都会导致重排，例如改变颜色，只会导致重绘。
* 重排会导致重绘，重绘不会导致重排
* 重绘和重排这两个操作都是比较昂贵的，因为 JavaScript 引擎线程与 GUI 渲染线程是互斥的，他们同时只能一个在工作
* 什么操作会导致重排？
    1. 添加或删除可见的 DOM 元素
    2. 元素位置改变
    3. 元素尺寸改变
    4. 内容改变
    5. 浏览器窗口尺寸改变
* 如何减少重绘重排？
    1. 用 JavaScript 修改样式时，最好不要直接写样式，而是替换 class 来改变样式
    2. 如果要对 DOM 元素执行一系列操作，可以将 DOM 元素脱离文档流，修改完成后，再将它待会文档。
    * 推荐使用隐藏元素（display: none）或文档碎片（DocumentFragement），都可以很好的实现这个方案
    