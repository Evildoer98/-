# 网络方面
## 01. 减少 HTTP 请求
* 一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并返回响应，浏览器接收响应等过程。

## 02. 使用 HTTP2
1. 解析速度快
    * 服务器解析 HTTP1.1 的请求时，必须不断地读入字节，知道遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每帧都有表示帧长度的字段
2. 多路复用
    * HTTP 1.1 如果要同时发起多个请求，就的建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求
    * 在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建
3. 首部压缩
    * HTTP2 提供了首部压缩功能
    * 两个请求中如果有很多相同的数据，将相同的首部存储起来，仅发送他们之间不同的部分，这样就可以节省不少的流量，加快请求时间
    * HTTP2 在客户端和服务端使用"首部表"来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送
    * eg：
        * 客服端按照顺序发送如下请求首部：
            ```    
                Header1: foo
                Header2: bar
                Header3: bat
            ```
        * 当客户端发送请求时，它会根据首部值创建一张表
            | 索引 | 首部名称 | 值 |
            | ---- | ---- | ---- |
            | 62 | Header1 | foo |
            | 63 | Header2 | bar |
            | 64 | Header3 | bat |
        * 服务器收到请求，照样会创建一张表。当客户端发送下一个请求的时候，如果首部相同，就可以直接发送这样的首部块
            ```
                62 63 64
            ```
        * 服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部
4. 优先级
    * HTTP 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理
5. 流量控制
    * 由于一个 TCP 连接流量带宽（根据客户端服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的溜溜多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制
6. 服务器推送
    * 服务器可以对一个客户端请求发送多个响应。
    * 即除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求
    * 例如：浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源

# 客户端渲染和服务端渲染（SSR）
## 客户端渲染
* 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，在渲染
* 渲染过程：（Vue SSR）
    1. 访问客户端渲染的网站
    2. 服务器返回一个包含了引入资源语句和 HTML 文件
    3. 客户端通过 HTTP 向服务器请求资源，当必要的资源都加载完毕后，执行 new Vue() 开始实例化并渲染页面

## 服务器渲染
* 服务器返回 HTML 文件，客户端只需解析 HTML
* 优点：首屏渲染快，SEO
* 缺点：配置麻烦，增加服务器的计算压力
* 渲染过程：(Vue SSR)
    1. 访问服务端渲染的网站
    2. 服务器会查看当前路由组件需要哪些资源文件，然后将这些文件填充到 HTML 文件。如果有 ajax 请求，就会执行它进行数据预取并填充到 HTML 文件里，最后返回这个 HTML 页面
    3. 当客户端接收到这个 HTML 页面时，就可以马上开始渲染页面。与此同时，页面也会加载资源，当必要的资源都加载完毕后，开始执行 new Vue() 开始实例化并接管页面

## 区别
* 区别在于第二步：客户端渲染的网站会直接返回 HTML 文件，而服务端渲染的网站则会渲染完页面再返回这个 HTML 文件

## 使用服务端渲染（SSR）的好处：内容更快的呈现
* eg：网站需要加载完 a b c d 四个文件才能渲染完毕。并且每个文件大小为 1M
    1. 客户端渲染的网站需要加载 4个文件 和 HTML 文件才能完成首页渲染，总计大小为 4M（忽略 HTML 文件大小）。
    2. 而服务端渲染的网站只需要加载一个渲染完毕的 HTML 文件就能完成首页渲染，总计大小为已经渲染完毕的 HTML 文件

# 静态资源使用 CDN
* 内容分布网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。CDN 在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间
## CDN 原理
* 当用户访问一个网站时，如果没有 CDN，过程是这样的：
    1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求
    2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址
    3. 本地 DNS 将 IP 地址发回给浏览器，浏览器再向网站服务器 IP 地址发出请求并得到资源
* 如果用户访问的网站部署了 CDN，过程是这样的：
    1. 浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求
    2. 本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址
    3. 本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS
    4. 本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求
    5. SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器
    6. 浏览器再根据 SLB 发回的地址重定向到缓存服务器
    7. 如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地
    
# 内容
## 1. 将 CSS 放在文件头部，JavaScript 文件放在底部
* 所有放在 head 标签里的 CSS 和 JS 文件都会阻塞渲染（CSS 不会阻塞 DOM 解析）。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。所以要将 JS 文件放在底部，等待 HTML 解析完了再加载 JS 文件
* 那为什么 CSS 文件还要放在头部呢？
    * 因为先加载 HTML 再加载 JS，会让用户第一时间看到的页面时没有样式的，为了避免这种情况发生，就要将 CSS 文件放在头部
    * 另外 JS 文件也是可以放在头部的，主要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行

## 2. 使用字体图标 iconfont 代替图片图标
* 字体图标是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size 、color 等等。并且字体图标是矢量图，不会失真。并且生成的文件特别小

# 图片优化
## 1. 图片延迟加载
* 在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载
1. 首先可以将图片这样设置，在页面不可见时图片不会加载
```html
    <img data-src="">
```
2. 等页面可见时，使用 JS 加载图片
```javascript
    const img = document.querySelector('img')
    img.src = img.dataset.src
```
