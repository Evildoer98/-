# XSS
* XSS：跨站脚本攻击（Cross Site Scripting）是最常见的基本攻击 WEB 网站方法，攻击者通过注入非法的 html 标签或者 JavaScript 代码，从而当用户浏览该网页时，控制用户浏览器
## XSS 分为三类：反射型（非持久型）、存储型（持久型）、基于 DOM
|类型|存储区|插入点|
|----|----|----|
|存储型 XSS|后端数据库|HTML|
|反射型 XSS|URL |HTML|
|DOM XSS|后端数据库/前端存储/URL|前端 JavaScript|
* 存储区：恶意代码存放的位置
* 插入点：由谁取得恶意代码，并插入到网页上

### 反射型 XSS
* 反射型 XSS 也被称为非持久性 XSS。
* 发出请求时，XSS 代码出现在 URL 中，最后输入提交到服务器，服务器解析后在响应内容中出现这段 XSS 代码，最后浏览器解析执行
* 攻击步骤：
    1. 攻击者构造出特殊的 URL，其中包含恶意代码
    2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器
    3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
    4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
* 常见于 通过 URL 穿度参数的功能 的场景：网站搜索、跳转等
* 由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击
* POST 的内容也可以触发反射型 XSS，只不过触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以很少见

### 存储型 XSS
* 存储型 XSS 也被称为持久性 XSS，是一种最危险的跨站脚本，相比反射型 XSS 和 基于 DOM 型 具有更高的隐蔽性
* 攻击步骤：
    1. 攻击者将恶意代码提交到目标网站的数据库中
    2. 用户打开目标网站，网站服务端将恶意代码从数据库中取出，拼接在 HTML 中返回给浏览器
    3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
    4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
* 常见在 带有用户保存数据的网站功能 的场景：论坛发帖、商品评论、用户私信等

### DOM型 XSS
* 攻击步骤：
    1. 攻击者构造出特殊的 URL，其中包含恶意代码
    2. 用户打开恶意代码的 URL
    3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行
    4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

### 总结
* 反射型 XSS 和 存储型 XSS 的区别是：
    1. 存储型 XSS 的恶意代码存在数据库里
    2. 反射型 XSS 的恶意代码存在 URL 里
* DOM 型 XSS 跟以上两种 XSS 的区别：
    1. DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞
    2. 而其他两种 XSS 都属于服务端的安全漏洞

## XSS 攻击的防范
* XSS 攻击的两大要素
    1. 攻击者提交恶意代码
    2. 浏览器执行恶意代码
        1. 防止 HTML 中出现注入
        2. 防止 JavaScript 执行时，执行恶意代码

* 用户输入检查
    * 此方法可以解决特定的 XSS 问题，但回引起很大的不确定性和乱码问题
    * eg：
        1. 当 5 &lt; 7 作为 HTML 拼接页面时，可以正常显示
        2. 当 5 &lt; 7 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等

* 服务器输出检查

### 预防存储型和反射型 XSS 攻击
* 存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者可以编写的“数据”被内嵌到“代码”中，被浏览器所执行
* 预防这两种漏洞，常见的两种做法
    1. 改成纯前端渲染，把代码和数据分隔开
    2. 对 HTML 做充分转义
1. 纯前端渲染
    * 过程：
        1. 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据
        2. 然后浏览器执行 HTML 中的 JavaScript
        3. JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上
    * 在纯前端渲染种，明确告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）
    * 但是需要注意避免 DOM 型 XSS 漏洞
2. 转义 HTML
    * 如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义
    * 常用的模板引擎，如：doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则就是把 & < > " ' / 这几个字符转义掉

### 预防 DOM 型 XSS 攻击
* DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了
* 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等
* 如果使用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患
* DOM 中的内联时间监听器，如 location、onclick、onerror。onload、onmouseover 等，< a > 标签的 href 属性，JavaScript 的 evel()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免

### 其他安全措施
1. 现在主流的浏览器内置了防范 XSS 的措施，例如：CSP（Content Security Policy）
    * 内容安全策略（CSP）：是一个额外的安全层，用于检测并削弱特定类型的攻击，包括跨站脚本攻击（XSS）和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要手段
    * 严格的 CSP 在 XSS 的防范中可以起到一下的作用：
        1. 禁止加载外域代码，防止复杂的攻击逻辑
        2. 禁止外域提交，网站被攻击后，用户的数据不会被泄露到外域
        3. 禁止内联脚本执行（规则较严格，GitHub 在使用）
        4. 禁止未授权的脚本执行（新特新，Google Map 移动端在使用）
        5. 合理使用上报可以及时发现 XSS，利于尽快修复问题

2. HttpOnly 防止劫取 Cookie，浏览器将禁止页面的 JavaScript 访问带有HttpOnly 属性的 Cookie
    * 严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击

3. 验证码：防止脚本冒充用户提交危险操作

4. 输入内容长度控制

# CSRF
## 攻击原理
* CSRF(Cross site request forgery)，即跨站请求伪造
* 而 CSRF 却是借用用户的身份，向 web server 发送请求，因为该请求不是用户本意，所以称为“跨站请求伪造”，
* 攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求，利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的
* eg：典型的 CSRF 攻击流程
    1. 受害者登录 a.com，并保留了登录凭证
    2. 攻击者引诱受害者访问了 b.com
    3. b.com 向 a.com 发送了一个请求：a.com/action=xxx
    4. a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
    5. a.com 以受害者的名义执行了 action = xxx
    6. 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作

## 常见的攻击类型
1. GET 类型的 CSRF
    * GET 类型的 CSRF 利用非常简单，只需要一个 HTTP，一般会这样利用
    ```javascript
        <img src = "http://bank.example/withdraw?amount=1000%for=hacker">
    ```
    * 在受害者访问含有这个 img 的页面后，浏览器会自动向 http://bank.example/withdraw?amount=1000%for=hacker 发出一次 HTTP 请求。bank.example 就会收到包含受害者登录信息的依次跨域请求

2. POST 类型的 CSRF
* 这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单
* eg：
    ```javascript
        <form action="http://bank.example/withdraw" method=POST>
            <input type="hidden" name="account" value="xiaoming" />
            <input type="hidden" name="amount" value="10000" />
            <input type="hidden" name="for" value="hacker" />
        </form>
        <script> document.forms[0].submit(); </script> 
    ```
    * 访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 请求
* POST 类型的攻击通常比 GET 要求更加严格一点。任何个人网站、博客，被黑客上传页面的网站的都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许 POST 上面

3. 链接类型的 CSRF
* 链接类型的 CSRF 并不常见，比起其他两种用户打开页面就中招的情况下，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户点击
* eg：
    ```javascript
        <a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">重磅消息！！<a/>
    ```
    * 由于之前用户登录了信任的网站 A，并且保存了登录状态，只要用户主动访问上面的这个 PHP 页面，则表示攻击成功

## CSRF 的特点
1. 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生
2. 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，而不是直接窃取数据
3. 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”
4. 跨站请求可以利用各种方式：图片URL、超链接、CORS、Form 提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以追踪
* CRSF 通常是跨域的，因为外域通常更容易被攻击者掌控，但是如果本域下有容易被利用的功能，比如：发送图片和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险

## 防护策略
* CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增加自己网站针对 CSRF 的防护能力来提升安全性
* CSRF 的两个特点：
    1. CSRF （通常）发生在第三方域名
    2. CSRF 攻击者不能获取到 Cookie 等信息，只是使用
* 针对这两点
    * 阻止不明外域的访问
        1. 同源检测
        2. Samesite Cookie
    * 提交时要求附加本域才能获取的信息
        1. CSRF Token
        2. 双重 Cookie 验证

### 同源检测
* 既然 CSRF 大多来自第三方网站，那么就直接禁止外域（或者不受信任的域名）发起请求
* 如何判断请求是否来自于外域？
    * 在 HTTP 协议中，每一个异步请求都会携带两个 Header，用于标记来源域名
        * Origin Header
        * Referer Header
    * 这两个 Header 在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。服务器可以通过解析这两个 Header 中的域名，确定请求的来源域
#### 使用 Origin Header 确定来源域名
* 在部分与 CSRF 有关的请求中，请求的 Header 中会携带 Origin 字段。字段内包含请求的域名（不包含path及query）
* 如果 Origin 存在，那么直接使用 Origin 中的字段确认来源域名就可以
* 但是在 Origin 在以下两种情况下并不存在：
    1. IE11 同源策略：IE11 不会在跨站 CSRF 请求上添加 Origin 标头，Referer 头将仍然是唯一的标识。最根本原因是因为 IE11 对同源的定义和其他浏览器不同，有两个主要的区别
    2. 302 重定向：在 302 重定向之后 Origin 不包含在重定向的请求中，因为 Origin 可能会被认为是其他来源的敏感信息。对于 302 重定向的情况来说都是定向到新的服务器上的 URL，因此浏览器不想将 Origin 泄露到新的服务器上

#### 使用 Referer Header 确定来源域名
* 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，记录了该 HTTP 请求的来源地址，对于 Ajax 请求，图片和 script 等资源请求，Referer 为发起请求的页面地址。对于页面跳转，Referer 为打开页面历史记录的前一个页面地址，因此我们使用 Referer 中链接的 Origin 部分可以得知请求的来源域名
* 这种方法并非万无一失的，Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来将，这样并不是很安全。甚至在部分情况下，攻击者可以隐藏，甚至修改自己请求的 Referer

### CSRF防御
*   Referer Check
    因为伪造的请求一般是从第三方网站发起的，所以第一个防御方法就是判断referer 头，如果不是来自本网站的请求，就判定为CSRF攻击。但是该方法只能防御跨站的CSRF攻击，不能防御同站的CSRF攻击(虽然同站的CSRF更难)
*   使用验证码
    每一个重要的post提交页面，使用一个验证码，因为第三方网站是无法获得验证码的。还有使用手机验证码，比如转账是使用的手机验证码。
*   使用 token
    每一个网页包含一个web server产生的token,提交时，也将该token提交到服务器，服务器进行判断，如果token不对，就判定位CSRF攻击。
    将敏感操作get改为post,然后在表单中使用token. 尽量使用post也有利于防御CSRF攻击