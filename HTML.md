# HTML5
## HTML5 的新特性以及移除的元素
* HTML5 语义化标签是指正确的标签包含了正确的内容，接口良好，比如nva表示导航条，类似的还有article、header、footer等等标签
### 01. 新特性
*   新增语义化标签：nav、header、footer、aside、section、article、details、summary、dialog

*   音频、视频标签：audio、video

*   数据存储：localStorage(持久保存)、sessionStorage(临时存储)

*   canvas（画布）、Geolocation（地理定位）、websocket（通信协议）

*   input标签新增属性：placeholder、autocomplete、autofocus、required

*   拖拽释放：drag、drop
    
*   webworker(创建子线程)、websocket(长连接)

*   history API
        go、forward、back、pushstate
        应用：vue编程式导航的灵感来源；vue-router的history模式。

### 2. 移除的元素
*   纯表现的元素：basefont、big、center、font、s、strike、tt、u
*   对可用性产生负面影响的元素：frame、frameset、noframes

## 02. DOCTYPE标签
    DOCTYPE声明于文档最前面，告诉浏览器以何种方式来渲染页面。
    HTML5中的声明方式如下：

      !DOCTYPE html  使用最新的HTML5标准来解析渲染页面
    如果不写，就会进入混杂模式

* 严格模式：标准模式，指浏览器按照 W3C 标准解析代码
* 混杂模式：怪异模式、兼容模式，指浏览器用自己的方式解析代码，混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作

## 03. 行内元素、块级元素、空(void)元素有哪些
*   常用的块状元素有：
    div、 p、 h1 ... h6 、  ol 、  ul 、  dl 、  table 、  address 、  blockquote  、  form 
*   常用的内联元素有：
      a 、  span 、  br 、  i 、  em 、  strong 、  label 、  q 、  var 、  cite 、  code 
*   常用的内联块状元素有：
      img 、  input 
*   知名的空元素：
      br/    hr/    img/    input/    link/   meta/  
*   鲜为人知的是：
      area    base    col    command    embed 
      keygen    param    source    track    wbr 

## 04. Doctype 类型
*   该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档
*   HTML 4.01 规定了三种文档类型：Strict、Transitional以及Frameset
*   XHTML 1.0 规定了三种文档类型：Strict、Transitional以及Frameset
*   Standards 标准模式（严格模式）
*   Quirks 包容模式（怪异、兼容模式）

## 05. canvas是什么？ 怎样写Canvas
1. 概念：Canvas 是 HTML5 的一个元素，它使用 JavaScript 在网页上绘制图形。Canvas 是一个矩形区域，它的每一个像素都可以由 HTML5 语言来控制。
2. 使用方式：添加 canvas 标签 

## 06. 最新的 HTML5 标准的API是什么
* Canvas：Canvas 由 HTML 代码中定义的具有高度和宽度属性的可绘制区域组成。JavaScript 代码可以通过一组完整的绘图函数访问该区域，这与其他常见的 2D API 类似，因此允许动态生成图形。Canvas 的一些预期用途包括构建图形、动画、游戏和图像合成
* 媒体定时回访
* 离线存储数据库
* 文档编辑
* 拖放
* 跨文档消息传递
* 浏览器历史管理
* MIME 类型和协议处理程序注册

## 07. HTML5 drag api 
* dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发
* drag：事件主体是被拖放元素，在正在拖放被拖放元素时触发
* dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。
* dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。
* dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。
* drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。
* dragend：事件主体是被拖放元素，在整个拖放操作结束时触发 

# 属性问题
## 01. src和href的区别
*   href 是超文本引用，它是指向资源的位置，建立与目标文件的联系；
*   src 目的是把资源下载到页面中；
    浏览器解析 href 不会阻塞对文档的处理（这就是官方建议使用 link 引入而不是 @ import 的原因），src 会阻塞对文档的处理。

## 02. script 标签为什么要放在body标签的底部（defer、async）
*   因为浏览器在渲染html的时候是从上到下执行的，当遇到js文件的时候就会停止当前页面的渲染，转而去下载js文件，
*   如果将 script 标签放在头部，在文件很大的情况下将导致首屏加载时间延长，影响用户体验。
*   解决办法：
    1. 将 script 标签放在body的底部
    2. 通过 defer、async 属性将 js 文件转为异步加载
*   注意：
        defer和async的区别：首先都是实现js文件的异步加载，不阻塞页面的渲染；
        区别就是defer必须等到整个文档渲染完成后才执行，而async在加载完成后，会暂停html的解析，转去执行 js

## 03. 页面导入样式时，使用 link 和 @import 有什么区别
1. link 属于 HTML 标签，而 @import 是 CSS 提供的
2. 页面被加载时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完后再加载
3. @import 只在 IE5 以上才能被识别，而 link 属于 HTML 标签，无兼容问题
4. link 方式的样式的权重高于 @import 的权重

## 04. 锚点的作用是什么？如何设置锚点
*   锚点是文档中某行的一个记号，类似于书签，用于链接到文档中的某个位置
*   定义锚点后，可以创建直接跳到该锚点（页面中的某个小节）的链接，这样使用者就无需不停的滚动页面来寻找信息
*   在使用   a  元素创建锚点，可以使用 name 属性为其命名
    对其他元素，可以使用 id 属性为其命名

# 标签问题
## 01. table 和 div + css 的区别
1. 核心：速度和加载方式方面的区别
2. div：  div  加载方式是即读即加载，遇到   div  没有遇到   /div  的时候一样加载   div  中的内容，读多少加载多少
3. table：加载方式是完成后加载，遇到   table  后，在读到   /table  之前，  table  中的内容不加载

## 02. 语义化标签的理解
1. 用正确的标签做正确的事情！
2. html 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；
3. 在没有样式 CCS 情况下也以一种文档格式显示，并且是容易阅读的。
4. 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。
5. 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。

## 03. iframe
*   iframe是一种框架，也是一种很常见的网页嵌入方式
*   iframe的优点：
    1. iframe能够原封不动的把嵌入的网页展现出来。
    2. 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。
    3. 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。
    4. 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。
*   iframe的缺点：
    1. iframe 会阻塞主页面的 Onload 事件。
    2. 搜索引擎无法解读这种页面，不利于SEO（SEO：使用特定的技术将网站的各种关键词排名提升到特定搜索引擎的理想位置）
    3. iframe 和主页面共享连接池，而浏览器对相同域的链接有限制，所以会影响页面的并行加载
    如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以可以绕开以上两个问题。
    4. 会产生很多页面，不容易管理。
    5. iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。
    6. 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。
    7. 很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。
    8. iframe框架页面会增加服务器的http请求，对于大型网站是不可取的。
    现在基本上都是用Ajax来代替iframe，所以iframe已经渐渐的退出了前端开发。

## 04. label 的作用是什么
    label 元素不会向用户呈现任何特殊效果。
    在 label 元素内点击文本，就会触发此控件。
    就是说，当用户选择该标签时，浏览器就会自动将焦点转到和标签相关的表单控件上。

## 05. tite 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？
### title 与 h1
1. h1 标签写在网页的 body 中
2. title 标签写在网页的 head 中
3. h1 标签控制一段文字

### b 与 strong
1.   b  为了加粗而加粗，  strong  为了标明重点而加粗
2. 区别：一个是物理元素，一个是逻辑元素
    1. 物理元素所强调的是一种物理行为，比如把一段文字用 b 标记加粗了，浏览器加粗了这段文字，单纯的加粗，没有其他任何作用
    2. Strong 是强调，向浏览器传递强调某段文字的信息，而这个 Strong 就是逻辑元素，强调文档逻辑的，并非是通知浏览器应该如何显示

### i 与 em
1. i 是 Italic（斜体），而 em 是 emphasize（强调）

### 综上
    物理元素是告诉浏览器以何种格式显示文字
    逻辑元素是告诉浏览器有怎么样的重要性

## 06. display:inline、block、inline-block 的区别
01. display:block 就是将元素显示为块级元素
    * block 元素的特点
        1. 总是在新行上开始
        2. 高度、行高以及顶和底边距可控制
        3. 宽度缺省是它的容器的100%，除非设定一个宽度
        4.   div 、  p 、  h1 、  from 、  ul 、  li 都是块元素
02. display:inline 就是将元素显示为行内元素
    * inline 元素的特点
        1. 和其他元素在一行上
        2. 高、行高及顶和底边距不可改变
        3. 宽度就是它的文字或图片的宽度，不可改变
        4.   span 、  a 、  label 、  input 、  img 、  strong 、  em 都是行内元素
03. display:inline-block 将对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行，允许空格
    * inline-block 元素的特点
        1. 将对象呈递为内联对象，但是对象的内容作为块对象呈递
        2. 旁边的内联对象会被呈递在同一行内，允许空格
        （应用此特性的元素呈现为内联对象，周围元素保持在同一行，但可以设置宽度和高度的块元素的元素）

## 07. 实现一个圆形的可点击区域
1. map + area 或者 svg
2. border-radius
3. 纯js

## 08. meta标签
1. 核心：提供给页面一些元信息（名称 / 值对），有助于 SEO
2. 属性值：
    1. name ：名称 / 值对中的名称。author、description、keyword、generator、revised、others。把 content 属性关联到一个名称
    2. http-equiv ：没有 name 时，会采用这个属性的值。content-type、expires、refresh、set-cookie。把 content 属性关联到 http 头部
    3. content ：名称 / 值对中的值， 可以是任何有效的字符串。 始终要和 name 属性或 http-equiv 属性一起使用
    4. scheme ：用于指定要用来翻译属性值的方案

## 09. SVG
* SVG 表示（scalable vector graphics）可缩放矢量图形。一个基于文本的图形语言，可以绘制文本、线、点等的图形，因此可以轻松又快速的渲染
* SVG 使用 XML 格式定义图像
* SVG 可以成为任何复杂的组合图形。SVG 支持渐变、旋转、滤镜效果、JavaScript 接口等等功能，但是所有这些额外的语言特性，都需要在一个定义好的图形区域内实现。

## Canvas 和 SVG 图形的区别是什么？
|Canvas	                                                                   |  SVG|
|----                                                                      | ---- |
|通过 JavaScript 来绘制 2D 图形	                                             |是一种使用 XML 描述 2D 图形的语言|
|是HTML5提供的新元素canvas	                                                 |历史久远，并不是HTML5转悠的标签|
|位图（标量图），放大或改变尺寸会失真；逐像素进行渲染，依赖分辨率	              |矢量图，放大或改变尺寸不会失真；不依赖分辨率|
|弱的文本渲染能力（因为放大会失真）	                                           |最适合带有大型渲染区域的应用程序，比如谷歌地图（因为放大不会失真）|
|能够以 .png 或 .jpg 格式保存结果图像；能够引入 .png 或 .jpg格式的图片          |不能以 .png 或 .jpg 格式保存结果图像；不能引入 .png 或 .jpg格式的图片|
|不支持事件处理器（一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。）	|支持事件处理器（SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。）|
|不能被引擎抓取	                                                            |可以被引擎抓取 |
|---	                                                                   |复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）|
|最适合图像密集型的游戏，其中的许多对象会被频繁重绘	                            |不适合游戏应用|


# 缓存
## 01. cookie
1. cookie 是网站为了标识用户身份而存储在本地终端的数据
2. cookie 的作用是与服务器进行交互
3. cookie 的大小是受限的（4k）
4. 每次请求一个新的页面时，cookie 都会被发送过去，这样无形之中浪费了带宽
5. cookie 需要指定作用域，不可以跨域调用

## 02. sessionStorage
1. sessionStorage 用于本地保存一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且会话结束后数据也随之销毁
2. sessionStorage 不是一种持久化的本地存储，仅仅是会话级别

## 03. localStorage
1. 用于持久化本地存储，除非主动删除数据，否则数据永远不会过期的
2. 相当于一个轻量级的数据库
3. 在断网情况下读取本地缓存的 cookie
    1. 使用 localStorage 保存数据：localStorage.setItem(key, value)
    2. 使用 localStorage 获取保存的数据: localStorage.getItem(key);
    3. 清除 localStorage 保存的数据： localStorage.removeItem(key);
    4. 清除全部 localStorage 对象保存的数据: localStorage.clear();

## 04. web storage 和 cookie 的区别
1. web storage 的概念和 cookie 相似，区别就是它是为了更大容量存储设计的
2. cookie 的大小是受限的，并且每次请求一个新的页面的时候 cookie 都会被发送过去，这样无形之中浪费了带宽，另外 cookie 需要指定作用域，不可以跨域调用
3. web storage 拥有 setItem、getItem、removeItem、clear 等方法，不像 cookie 需要前端开发者自己封装 setCookie、getCookie
4. 但是 cookie 是不可或缺的：cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在

# 离线缓存
## 01. 什么是 cookie 隔离（请求资源的时候不让它携带cookie）
1. cookie 隔离技术和传统的多域名拆分请求，提高浏览器并发请求数有点类似，均是采用多域名来处理请求
2. 传统做法是将 css、js、图片等静态文件放在多个域名下面请求，这样就可以跨过浏览器对统一主机名并发连接数的限制，提高整体并发请求量
3. cookie 隔离技术则是通过使用多个非主要域名来请求静态文件，如果静态文件都放在主域名下，那静态文件请求的时候带有的 cookie 数据提交给 server 是非常浪费的
4. cookie 有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有 cookie 数据，这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。同时这种方式不会将 cookie 传入 webserver，也减少了 webserver 对 cookie 的处理分析环节，提高了 webserver 的 http 请求的解析速度
* 总结：
    1. 如果静态文件都放在主域名下，那静态文件请求的时候都带有的 cookie 的数据提交给 server 的，非常浪费流量
    2. 因为 cookie 有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会有 cookie 数据
    3. 这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的
    4. 同时这种方式不会将 cookie 传入 Web Server，也减少了 Web Server 对 cookie 的处理分析环节
    5. 提高了 Web Server 的 http 请求的解析速度

## 02. HTML5 的离线储存的使用和原理
* 两种方式
    1. HTML5 的离线存储 .appcache 文件 【弃用】
    2. service-worker 的标准

## 03. 浏览器如何对HTML的离线资源进行管理和加载
* 有线情况下：
    1. 浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储
    2. 如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储

* 离线情况下：
    浏览器直接使用离线缓存的资源

## 04. HTML 应用程序缓存和 HTML 浏览器缓存有什么区别
    新的 HTML5 规范的应用缓存最关键的就是 支持离线应用，允许浏览器在连接客户端时预取一些或全部网站资产，如 HTML 文件，图像、css以及js等，预取文件加速了站点的性能。
    换句话说，引用程序缓存可以预取完全未被访问的页面，从而在常规的浏览器缓存中不可用，与传统浏览器缓存比较，该性能并不强制要求用户访问网站

# 通信
## 如何实现浏览器内多个标签页之间的通信？
### localStorage
1. localStorage 是浏览器多个标签共用的存储空间，所以可以用来实现多标签之间的通信
    （注意：session 是会话级别的存储空间，每个标签页都是单独的）
2. 直接在 window 对象上添加监听 storage 事件即可
3. onstorage 以及 storage 事件，针对都是非当前页面对 localStorage 进行修改时才会触发，当前页面修改 localStorage 不会触发监听函数。然后就是在对原有的数据的值进行修改时才会触发。

### webworker
* JavaScript 是单线程的，但是浏览器是拥有多个线程的：GUI 渲染线程，JS 引擎线程、事件触发线程、异步 http 请求线程
* webworker 作为浏览器的一个新特性，可以提供一个额外的线程来执行一些 js 代码，并且不会影响到浏览器用户界面
* 应用场景：页面中包含耗时较大的算法代码时，就会阻塞线程影响浏览器渲染等等。这时将耗时代码，放到 webworker 中执行
* 注意：这种多线程能力不是 JavaScript 语言原生具有的，而是浏览器宿主环境提供的
* 普通的 webworker 直接使用 new Worker() 即可创建，这种 webworker 是当前页面专有的，然后还有种共享的 worker（SharedWorker），这种是可以多个标签页、iframe 共同使用的

### cookie + setInterval
* 将要传递的信息存储在 cookie 中，每隔一定时间读取 cookie 信息，即可随时获取要传递的信息

### SharedWorker
1. SharedWorker 可以被多个 window 共同使用，但必须保证这些标签页都是同源的（相同的协议、主机、端口号）

### WebSocket

# 其他
## 01. 网页制作会用到的图片格式有那些？
*   png-8，png-24，jpeg，gif，svg　
    但是上面的那些都不是面试官想要的最后答案。面试官希望听到是Webp,Apng。（是否有关注新技术，新鲜事物）　　
    科普一下：
*   Webp：WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。
         Facebook Ebay等知名网站已经开始测试并使用WebP格式。在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。　　
*   Apng：全称是“Animated Portable Network Graphics”,是PNG的位图动画扩展，可以实现png格式的动态图片效果。
    04年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到 iOS safari 8的支持，有望代替GIF成为下一代动态图标准。

## 02. 阻止事件冒泡&取消默认行为
*    阻止事件冒泡
        w3c：e.stopPropagation()
        ie9以下：e.cancelBubble = true
*    取消默认行为
        w3c：e.preventDefault()
        ie：e.returnValue = false
*    return false
        js：取消默认行为
        jQuery：阻止冒泡 + 取消默认行为
*     vue方法（修饰符）
        阻止事件冒泡：@click.stop
        取消默认行为：@click.prevent

## 03. 从输入网址（URL）到页面显示的过程？(一次完整的http请求)
*    域名解析，对输入的url进行dns域名解析，得到对应的ip地址
    1. 构建请求：浏览器会构建请求行
    2. 查找强缓存：先检查强缓存，如果命中直接使用，否则进入下一步
    3. DNS解析：浏览器提供了DNS数据缓存功能，如果一个域名已经解析过，那么把解析的结果缓存下来，下次处理直接走缓存，不需要经过DNS解析
*    根据这个ip地址，找到对应的服务器，发起tcp连接（三次握手）
*    建立tcp连接后发送http请求
*    服务器响应http请求，浏览器得到html代码
        ETag:为相应头部字段，表示资源内容的唯一标识，随服务器response返回
        协商缓存，状态码304，直接从浏览器缓存中读取
*    浏览器解析html代码，并请求html代码中的js、css、图片等资源
*    浏览器对页面进行渲染并呈现给用户
*    断开TCP连接（四次挥手）

## 04. HTML页面渲染过程
*     渲染页面（过程）
           并行构建
    html    dom树                   
                      render tree   计算布局信息（Layout）   UI引擎渲染（paint）   用户所见
    css    css结构体
                                         回流（重排）                   重绘

* 总体过程：
    1. 解析html文件（非上下文无关文法：需考虑上下文），创建DOM树
    2. 解析css，生成CSSOM（CSS Object Model），即CSS对象模型
    3. dom和css合并，构建渲染树（render tree）
    4. layout 布局（渲染）
        依照盒子模型，计算每个节点在屏幕中的尺寸和位置
    5. painting 绘制（渲染）
        按照计算出来的规则，通过显卡，将内容画到屏幕上
    6. 重新渲染
        * 重排（即重新layout）：元素的大小或者位置发生了变化（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算布局和渲染
        * 重绘（即重新paint）：元素样式的改变（但宽高、大小、位置等不变）
        * 特点：
            1. 重绘不是很消耗性能
            2. 回流很消耗性能（DOM元素的大小和位置信息都要重新计算一遍），而且一旦发生回流，重新计算完后，还需要重绘
            3. 回流一定会触发重绘，而重绘不一定会回流

## 05. webSocket 如何兼容低浏览器
* Adobe Flash Socket
* ActiveX HTMLFile（IE）
* 基于 multipart 编码发送 XHR
* 基于长轮询的 XHR

## 06. 浏览器乱码
* 原因：
    1. 网页源代码是 gbk 的编码，而内容中的中文字是 utf-8，这样浏览器打开即会出现 html 乱码。反之也会出现乱码
    2. html 网页编码是 gbk，而程序从数据库中调出呈现的是 utf-8 编码的内容也会造成编码乱码
    3. 浏览器不能自动检测网页编码，造成网页乱码
* 解决方法：
    1. 使用软件进行编辑 HTML 网页内容
    2. 如果网页设置的编码是 gbk，而数据库存储数据编码格式是 utf-8，此时需要程序查询数据库显示数据前进行转码
    3. 如果浏览器浏览时候出现乱码，在浏览器中找到转换编码的菜单进行转换

## 06. 页面可见性（Page Visibility）API 可以有哪些用途
    在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放。

## 07. 为什么用多个域名来存储网站资源会更有效
1. CDN 缓存更加方便
2. 突破浏览器并发限制
3. 节约 cookie 带宽
4. 节约主域名的连接数，优化页面下响应速度
5. 防止不必要的安全问题

## 08. 说一下web Quality（无障碍） 
*   能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站
*   残障人士指的是那些带有残疾或者身体不健康的用户
    使用alt属性：<img src="person.jpg"  alt="this is a person"/> 
*   有时候浏览器会无法显示图像。具体的原因有：
    1. 用户关闭了图像显示
    2. 浏览器是不支持图形显示的迷你浏览器
    3. 浏览器是语音浏览器（供盲人和弱视人群使用）
    * 如果您使用了alt 属性，那么浏览器至少可以显示或读出有关图像的描述。

# 优化
## 01. 如何减少回流Reflow和重绘Repaint
1. 放弃传统操作 DOM 的时代，基于 vue/react 开始数据影响视图模式
    * mvvm / mvc / virtual dom / dom diff ......
    * vue / react  数据驱动思想 :
        我们自己不操作DOM，我们只操作数据，让框架帮我们根据数据渲染视图（框架内部本身对于DOM的回流和重绘以及其它性能优化做的非常好）
2. 分离读写操作（现代浏览器的渲染队列的机制）（重要）
3. 样式集中改变（不重要）
4. 缓存布局信息（不重要）
    把要操作的内容一次都拿到，然后用变量存储，想设置的时候直接拿变量值即可，不用在重新获取了，和分离读写的原理类似
5. 元素批量修改（重要）
    1. 文档碎片：临时创建的一个存放文档的容器，我们可以把新创建的Li，存放到容器中，当所有的Li都存储完，我们统一把容器中的内容增加到页面中（只触发一次回流）
    2. 字符串拼接：项目中，有一个文档碎片类似的方式，也是把要创建的Li事先存储好，最后统一放到页面中渲染（字符串拼接）
6. 动画效果应用到position属性为absolute或fixed的元素上（脱离文档流）
    也会引起回流重绘，只不过从新计算过程中，因为他脱离文档流了，不会对其他元素产生影响，重新计算的过程中比较快一点
7. CSS硬件加速（GPU加速）
    比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘：transform/opacity/filters......这些属性会触发硬件加速，不会引发回流和重绘......
    可能会引发坑：过多使用会占用大量内存，性能消耗严重，有时候会导致字体模糊等
8. 牺牲平滑度换取速度
    每次1像素移动一个动画，但是如果此动画使用了100%的CPU，动画就会看上去是跳动的，因为浏览器正在与回流做东征。每次移动3像素可能开起来平滑度低了，但它不会导致CPU在较慢的机器中抖动
9. 避免table布局和使用css的JavaScript表达式

## 02. 懒加载和预加载
### 1. 什么是懒加载
*   懒加载也叫延迟加载，指的是长网页中延迟加载图像，是一种很好优化网页性能的方式
* 用户在滚动到他们之前，可视区域外的图像不会加载。这与图像预加载相反，在长网页上使用延迟加载将使网页加载更快
* 在某些情况下，它还可以帮助减少服务器负载
* 常用于：图片很多，页面很长的电商网站场景中
### 2. 为什么要用懒加载
*   能提升用户体验：
*   减少无效资源的加载：减少服务器的压力和流量，也能够减少浏览的负担
*   防止并发加载的资源过多会阻塞js的加载：影响网站的正常使用
### 3. 懒加载的原理
1. 首先将页面上的图片src属性设为空字符串，而图片的真实路径则设置在data-original属性中，当页面滚动的时候需要去监听scroll事件
2. 在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域，如果图片在可视区域内将图片的src属性设置为data-original的值，这样就可以实现延迟加载
### 4. 是什么预加载
* 资源预加载是另一个性能优化技术，我们可以使用该技术来原先告知浏览器那些资源可能在将来会被使用到。
* 预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要时候到时就可以直接从缓存取资源
### 5. 为什么要用预加载
* 在网页全部加载之前，对于一些主要内容进行加载，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现一片空白，知道所有内容加载完毕
### 6. 实现预加载的方法
1.  使用HTML标签
2.  使用Image对象
3.  使用XMLHttpRequest对象，虽然存在跨域问题，但会精细控制预加载过程

## 03. 如何进行网站性能优化
### 1. content方面
1. 减少HTTP请求：合并文件、CSS精灵、inline Image
2. 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何文件
    方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
3. 避免重定向：多余的中间访问
4. 使Ajax可缓存
5. 非必须组件延迟加载
6. 未来所需组件预加载
7. 减少DOM元素数量
8. 将资源放到不同的域下：浏览器同时从同一个域下载资源的数目有限，增加域可以提高并行下载量
9. 减少iframe数量
10. 不要404
### 2. Server方面
1. 使用CDN
2. 添加Expires或者Cache-Control响应头
3. 对组件使用Gzip压缩
4. 配置ETag
5. Flush Buffer Early
6. Ajax使用GET进行请求
7. 避免空src的img标签
### 3. Cookie
1. 减小Cookie大小
2. 引入资源的域名不要包含cookie
### 4. CSS方面
1. 将样式表放在页面顶部
2. 不使用CSS表达式
3. 不使用@import
4. 不使用IE的Filter
### 5. JavaScript方面
1. 将脚本放在页面底部
2. 将JavaScript和CSS从外部引入
3. 压缩JavaScript和CSS
4. 删除不需要的脚本
5. 减少DOM访问
6. 合理设计事件监听器
### 6. 图片方面
1. 优化图片：根据实际颜色需要选择色深、压缩
2. 优化CSS精灵
3. 不要在HTML中拉伸图片
4. 保证favicon.ico小并且可缓存
### 7. 移动方面
1. 保证组件小于25k
2. Pack Components into a Multipart Document

## 04. 渐进增强
    渐进增强是指在web设计时强调课访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能，同时为高级浏览器和高带宽用户提供更好的用户体验。
1. 所有浏览器都必须能访问基本内容
2. 所有浏览器都必须能使用基本功能
3. 所有内容都包含在语义化标签中
4. 通过外部CSS提供增强的布局
5. 通过非侵入式、外部JavaScript提供增强功能
6. end-user web browser preferences are respoected

## 05. 优雅降级
    一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容
    是从复杂的现状开始，并试图减少用户体验到的供给


## 06. 优化缓存处理
*   dns缓存、cdn缓存、浏览器缓存、服务器缓存

## 07. 前端从哪些方面做性能优化？（加载层面）
1. 减少http请求（精灵图，雪碧图，CSS .js文件的合并，用CSS代替图片）
2. 减少文件大小（资源压缩，webpack，GZip压缩，图片压缩）
3. CDN（大图加载，大文件，类库）
4. http2
5. SSR服务端渲染，预渲染...
6. 懒加载，减少首屏加载量
7. 减少回流，使用定位（脱离文档流）等，对于操作量比较大的dom，用文档碎片去做（虚拟dom原理）
8. 缓存（cache）

## 08. 做好SEO
* SEO(Search Engine Optimization)，即搜索引擎优化。SEO是随着搜索引擎的出现而来的，两者是相互促进，互利共生的关系。SEO的存在就是为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。而优化的目的就是为了提升网站在搜索引擎中的权重，增加对搜索引擎的友好度，使得用户在访问网站时能排在前面。